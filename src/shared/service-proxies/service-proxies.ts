/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.12.7.0 (NJsonSchema v9.10.6.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, OpaqueToken } from '@angular/core';
import { Http, Headers, ResponseContentType, Response } from '@angular/http';

import * as moment from 'moment';

export const API_BASE_URL = new OpaqueToken('API_BASE_URL');

@Injectable()
export class ApplicantServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getApplicant(id: number): Observable<ApplicantDto> {
        let url_ = this.baseUrl + "/api/Applicant/GetApplicant?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetApplicant(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetApplicant(response_);
                } catch (e) {
                    return <Observable<ApplicantDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ApplicantDto>><any>Observable.throw(response_);
        });
    }

    protected processGetApplicant(response: Response): Observable<ApplicantDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApplicantDto.fromJS(resultData200) : new ApplicantDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ApplicantDto>(<any>null);
    }

    /**
     * @return Success
     */
    getApplicants(): Observable<ApplicantDto[]> {
        let url_ = this.baseUrl + "/api/Applicant/GetApplicants";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetApplicants(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetApplicants(response_);
                } catch (e) {
                    return <Observable<ApplicantDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ApplicantDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetApplicants(response: Response): Observable<ApplicantDto[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ApplicantDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ApplicantDto[]>(<any>null);
    }

    /**
     * @firstName (optional) 
     * @lastName (optional) 
     * @dateOfBirth (optional) 
     * @mailAddress (optional) 
     * @phoneNo (optional) 
     * @mobileNo (optional) 
     * @address (optional) 
     * @return Success
     */
    createApplicant(firstName: string, lastName: string, dateOfBirth: moment.Moment, mailAddress: string, phoneNo: string, mobileNo: string, address: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Applicant/CreateApplicant?";
        if (firstName !== undefined)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&"; 
        if (lastName !== undefined)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&"; 
        if (dateOfBirth !== undefined)
            url_ += "DateOfBirth=" + encodeURIComponent(dateOfBirth ? "" + dateOfBirth.toJSON() : "") + "&"; 
        if (mailAddress !== undefined)
            url_ += "MailAddress=" + encodeURIComponent("" + mailAddress) + "&"; 
        if (phoneNo !== undefined)
            url_ += "PhoneNo=" + encodeURIComponent("" + phoneNo) + "&"; 
        if (mobileNo !== undefined)
            url_ += "MobileNo=" + encodeURIComponent("" + mobileNo) + "&"; 
        if (address !== undefined)
            url_ += "Address=" + encodeURIComponent("" + address) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateApplicant(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateApplicant(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCreateApplicant(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @firstName (optional) 
     * @lastName (optional) 
     * @dateOfBirth (optional) 
     * @mailAddress (optional) 
     * @phoneNo (optional) 
     * @mobileNo (optional) 
     * @address (optional) 
     * @isActive (optional) 
     * @return Success
     */
    updateApplicant(id: number, firstName: string, lastName: string, dateOfBirth: moment.Moment, mailAddress: string, phoneNo: string, mobileNo: string, address: string, isActive: boolean): Observable<void> {
        let url_ = this.baseUrl + "/api/Applicant/UpdateApplicant?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (firstName !== undefined)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&"; 
        if (lastName !== undefined)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&"; 
        if (dateOfBirth !== undefined)
            url_ += "DateOfBirth=" + encodeURIComponent(dateOfBirth ? "" + dateOfBirth.toJSON() : "") + "&"; 
        if (mailAddress !== undefined)
            url_ += "MailAddress=" + encodeURIComponent("" + mailAddress) + "&"; 
        if (phoneNo !== undefined)
            url_ += "PhoneNo=" + encodeURIComponent("" + phoneNo) + "&"; 
        if (mobileNo !== undefined)
            url_ += "MobileNo=" + encodeURIComponent("" + mobileNo) + "&"; 
        if (address !== undefined)
            url_ += "Address=" + encodeURIComponent("" + address) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateApplicant(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateApplicant(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateApplicant(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteApplicant(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Applicant/DeleteApplicant?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteApplicant(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteApplicant(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteApplicant(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class ApplicantWorkflowServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getApplicantWorkflows(): Observable<ApplicantWorkflowDto[]> {
        let url_ = this.baseUrl + "/api/ApplicantWorkflow/GetApplicantWorkflows";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetApplicantWorkflows(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetApplicantWorkflows(response_);
                } catch (e) {
                    return <Observable<ApplicantWorkflowDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ApplicantWorkflowDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetApplicantWorkflows(response: Response): Observable<ApplicantWorkflowDto[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ApplicantWorkflowDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ApplicantWorkflowDto[]>(<any>null);
    }

    /**
     * @applicantId (optional) 
     * @workflowId (optional) 
     * @return Success
     */
    createApplicantWorkflow(applicantId: number, workflowId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/ApplicantWorkflow/CreateApplicantWorkflow?";
        if (applicantId !== undefined)
            url_ += "ApplicantId=" + encodeURIComponent("" + applicantId) + "&"; 
        if (workflowId !== undefined)
            url_ += "WorkflowId=" + encodeURIComponent("" + workflowId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateApplicantWorkflow(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateApplicantWorkflow(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCreateApplicantWorkflow(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class ExperienceServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getExperiences(): Observable<ExperienceDto[]> {
        let url_ = this.baseUrl + "/api/Experience/GetExperiences";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetExperiences(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetExperiences(response_);
                } catch (e) {
                    return <Observable<ExperienceDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ExperienceDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetExperiences(response: Response): Observable<ExperienceDto[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ExperienceDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ExperienceDto[]>(<any>null);
    }

    /**
     * @applicantId (optional) 
     * @companyName (optional) 
     * @fromDate (optional) 
     * @toDate (optional) 
     * @designation (optional) 
     * @companyWebsite (optional) 
     * @projects (optional) 
     * @technologies (optional) 
     * @return Success
     */
    createExperience(applicantId: number, companyName: string, fromDate: moment.Moment, toDate: moment.Moment, designation: string, companyWebsite: string, projects: string, technologies: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Experience/CreateExperience?";
        if (applicantId !== undefined)
            url_ += "ApplicantId=" + encodeURIComponent("" + applicantId) + "&"; 
        if (companyName !== undefined)
            url_ += "CompanyName=" + encodeURIComponent("" + companyName) + "&"; 
        if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&"; 
        if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&"; 
        if (designation !== undefined)
            url_ += "Designation=" + encodeURIComponent("" + designation) + "&"; 
        if (companyWebsite !== undefined)
            url_ += "CompanyWebsite=" + encodeURIComponent("" + companyWebsite) + "&"; 
        if (projects !== undefined)
            url_ += "Projects=" + encodeURIComponent("" + projects) + "&"; 
        if (technologies !== undefined)
            url_ += "Technologies=" + encodeURIComponent("" + technologies) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateExperience(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateExperience(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCreateExperience(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @applicantId (optional) 
     * @companyName (optional) 
     * @fromDate (optional) 
     * @toDate (optional) 
     * @designation (optional) 
     * @companyWebsite (optional) 
     * @projects (optional) 
     * @technologies (optional) 
     * @return Success
     */
    updateExperience(id: number, applicantId: number, companyName: string, fromDate: moment.Moment, toDate: moment.Moment, designation: string, companyWebsite: string, projects: string, technologies: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Experience/UpdateExperience?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (applicantId !== undefined)
            url_ += "ApplicantId=" + encodeURIComponent("" + applicantId) + "&"; 
        if (companyName !== undefined)
            url_ += "CompanyName=" + encodeURIComponent("" + companyName) + "&"; 
        if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&"; 
        if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&"; 
        if (designation !== undefined)
            url_ += "Designation=" + encodeURIComponent("" + designation) + "&"; 
        if (companyWebsite !== undefined)
            url_ += "CompanyWebsite=" + encodeURIComponent("" + companyWebsite) + "&"; 
        if (projects !== undefined)
            url_ += "Projects=" + encodeURIComponent("" + projects) + "&"; 
        if (technologies !== undefined)
            url_ += "Technologies=" + encodeURIComponent("" + technologies) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateExperience(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateExperience(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateExperience(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @experienceId (optional) 
     * @return Success
     */
    deleteExperience(experienceId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Experience/DeleteExperience?";
        if (experienceId !== undefined)
            url_ += "ExperienceId=" + encodeURIComponent("" + experienceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteExperience(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteExperience(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteExperience(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class WorkflowServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getWorkflow(id: number): Observable<WorkflowDto> {
        let url_ = this.baseUrl + "/api/Workflow/GetWorkflow?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetWorkflow(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetWorkflow(response_);
                } catch (e) {
                    return <Observable<WorkflowDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<WorkflowDto>><any>Observable.throw(response_);
        });
    }

    protected processGetWorkflow(response: Response): Observable<WorkflowDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkflowDto.fromJS(resultData200) : new WorkflowDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<WorkflowDto>(<any>null);
    }

    /**
     * @return Success
     */
    getWorkflows(): Observable<WorkflowDto[]> {
        let url_ = this.baseUrl + "/api/Workflow/GetWorkflows";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetWorkflows(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetWorkflows(response_);
                } catch (e) {
                    return <Observable<WorkflowDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<WorkflowDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetWorkflows(response: Response): Observable<WorkflowDto[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(WorkflowDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<WorkflowDto[]>(<any>null);
    }

    /**
     * @processName (optional) 
     * @processOrder (optional) 
     * @return Success
     */
    createWorkflow(processName: string, processOrder: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/CreateWorkflow?";
        if (processName !== undefined)
            url_ += "ProcessName=" + encodeURIComponent("" + processName) + "&"; 
        if (processOrder !== undefined)
            url_ += "ProcessOrder=" + encodeURIComponent("" + processOrder) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateWorkflow(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateWorkflow(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCreateWorkflow(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @processName (optional) 
     * @processOrder (optional) 
     * @return Success
     */
    updateWorkflow(id: number, processName: string, processOrder: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/UpdateWorkflow?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (processName !== undefined)
            url_ += "ProcessName=" + encodeURIComponent("" + processName) + "&"; 
        if (processOrder !== undefined)
            url_ += "ProcessOrder=" + encodeURIComponent("" + processOrder) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateWorkflow(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateWorkflow(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateWorkflow(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteWorkflow(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/DeleteWorkflow?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteWorkflow(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteWorkflow(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteWorkflow(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

export class ApplicantDto implements IApplicantDto {
    id: number;
    firstName: string;
    lastName: string;
    dateOfBirth: moment.Moment;
    mailAddress: string;
    phoneNo: string;
    mobileNo: string;
    address: string;
    isActive: boolean;

    constructor(data?: IApplicantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.dateOfBirth = data["dateOfBirth"] ? moment(data["dateOfBirth"].toString()) : <any>undefined;
            this.mailAddress = data["mailAddress"];
            this.phoneNo = data["phoneNo"];
            this.mobileNo = data["mobileNo"];
            this.address = data["address"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): ApplicantDto {
        let result = new ApplicantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["mailAddress"] = this.mailAddress;
        data["phoneNo"] = this.phoneNo;
        data["mobileNo"] = this.mobileNo;
        data["address"] = this.address;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IApplicantDto {
    id: number;
    firstName: string;
    lastName: string;
    dateOfBirth: moment.Moment;
    mailAddress: string;
    phoneNo: string;
    mobileNo: string;
    address: string;
    isActive: boolean;
}

export class ApplicantWorkflowDto implements IApplicantWorkflowDto {
    id: number;
    applicantId: number;
    applicant: ApplicantDto;
    workflowId: number;
    workflow: WorkflowDto;
    actionTime: moment.Moment;

    constructor(data?: IApplicantWorkflowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.applicantId = data["applicantId"];
            this.applicant = data["applicant"] ? ApplicantDto.fromJS(data["applicant"]) : <any>undefined;
            this.workflowId = data["workflowId"];
            this.workflow = data["workflow"] ? WorkflowDto.fromJS(data["workflow"]) : <any>undefined;
            this.actionTime = data["actionTime"] ? moment(data["actionTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicantWorkflowDto {
        let result = new ApplicantWorkflowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["applicantId"] = this.applicantId;
        data["applicant"] = this.applicant ? this.applicant.toJSON() : <any>undefined;
        data["workflowId"] = this.workflowId;
        data["workflow"] = this.workflow ? this.workflow.toJSON() : <any>undefined;
        data["actionTime"] = this.actionTime ? this.actionTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IApplicantWorkflowDto {
    id: number;
    applicantId: number;
    applicant: ApplicantDto;
    workflowId: number;
    workflow: WorkflowDto;
    actionTime: moment.Moment;
}

export class WorkflowDto implements IWorkflowDto {
    id: number;
    processName: string;
    processOrder: number;

    constructor(data?: IWorkflowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.processName = data["processName"];
            this.processOrder = data["processOrder"];
        }
    }

    static fromJS(data: any): WorkflowDto {
        let result = new WorkflowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["processName"] = this.processName;
        data["processOrder"] = this.processOrder;
        return data; 
    }
}

export interface IWorkflowDto {
    id: number;
    processName: string;
    processOrder: number;
}

export class ExperienceDto implements IExperienceDto {
    id: number;
    applicantId: number;
    companyName: string;
    fromDate: moment.Moment;
    toDate: moment.Moment;
    designation: string;
    companyWebsite: string;
    projects: string;
    technologies: string;

    constructor(data?: IExperienceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.applicantId = data["applicantId"];
            this.companyName = data["companyName"];
            this.fromDate = data["fromDate"] ? moment(data["fromDate"].toString()) : <any>undefined;
            this.toDate = data["toDate"] ? moment(data["toDate"].toString()) : <any>undefined;
            this.designation = data["designation"];
            this.companyWebsite = data["companyWebsite"];
            this.projects = data["projects"];
            this.technologies = data["technologies"];
        }
    }

    static fromJS(data: any): ExperienceDto {
        let result = new ExperienceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["applicantId"] = this.applicantId;
        data["companyName"] = this.companyName;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["designation"] = this.designation;
        data["companyWebsite"] = this.companyWebsite;
        data["projects"] = this.projects;
        data["technologies"] = this.technologies;
        return data; 
    }
}

export interface IExperienceDto {
    id: number;
    applicantId: number;
    companyName: string;
    fromDate: moment.Moment;
    toDate: moment.Moment;
    designation: string;
    companyWebsite: string;
    projects: string;
    technologies: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}